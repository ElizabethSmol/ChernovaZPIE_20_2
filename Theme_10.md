# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнила:
- Чернова Елизавета Андреевна
- ЗПИЭ-20-2

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 | + |
| Задание 2 | + | 
| Задание 3 | + | 
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на Py, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. Подсказка: необходимо использовать модуль time. Декоратор необходимо использовать для этой функции:

![Меню](https://github.com/ElizabethSmol/ChernovaZPIE_20_2/blob/pic/sam_10_1_ex.PNG)
### Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы.
### Также на этом примере можете посмотреть, что решение задач через рекурсию не всегда является хорошей идеей. Поскольку решение Фибоначчи для 100 с использованием рекурсии и без динамического программирования решается более десяти секунд, а решение точно такой же задачи, но через цикл for еще и для 200, занимает меньше 1 секунды.

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"\nФункция {func.__name__} выполнилась за {execution_time} секунд")
        return result
    return wrapper

@timing_decorator
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=" ")


if __name__ == "__main__":
    fibonacci()
```

### Результат.
![Меню](https://github.com/ElizabethSmol/ChernovaZPIE_20_2/blob/pic/sam_10_1.PNG)

## Выводы

Если так, он вызывает функцию fibonacci().

Однако в вашем коде есть несколько пр

В данном коде импортируется модуль time, определяется декоратор для измерения времени: timing_decorator, две функции def timing_decorator(func): и def wrapper(*args, **kwargs):, блок кода if __name__ == "__main__":, в котором проверяется главная программа и выводятся строки с использованием функции `print()`. Строки содержат значение:

1. `print(f"\nФункция {func.name} выполнилась за {execution_time} секунд")`: выводит сообщение, указывая имя выполненной функции и время выполнения;
2. `print(fib2, end=" ")`: Выводятся числа фибоначчи

## Самостоятельная работа №2
###  Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение ("бросить исключение") и вывести в консоль "файл пустой" , а если он не пустой, то вывести информацию из файла.

```python
def read_file(test: str) -> None:
    try:
        with open(test, "r") as file:
            data = file.read()

            if not data:
                raise Exception("Файл пустой")

            print("Данные из файла: \n", data)

    except Exception as e:
        print("Ошибка:", e)

str = input("Введите путь к файлу:")
read_file(str)
```
### Результат.
![Меню](https://github.com/ElizabethSmol/ChernovaZPIE_20_2/blob/pic/sam_10_2.PNG)
![Меню](https://github.com/ElizabethSmol/ChernovaZPIE_20_2/blob/pic/sam_10_2_1.PNG)

## Выводы

В данном коде определяется функция read_file, которая принимает аргумент test (путь к файлу) и не возвращает ничего (-> None), в ней открывается файл, указанный в аргументе test, в режиме чтения ("r") и сохраняется в data

1. `Exception("Файл пустой")`: Выполняется проверка, при пустом файле выполняется исключение Exception с сообщением "Файл пустой".
2. `print("Данные из файла: \n", data)`: Если файл не пустой (и исключение не было сгенерировано), то функция выводит содержимое файла на экран, добавляя строку "Данные из файла:" перед выводом данных.
3. `print("Ошибка:", e)`: Если в блоке try возникает какая-либо ошибка (например, файл не существует), то она перехватывается в блоке except, и сообщение об ошибке выводится на экран.
   
## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка *Неподходящий тип данных. Ожидалось число ?* Реализовать функционал программы необходимо через try/ехсept и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль

```python
def add_two():
    try:
        user_input = input("Введите число: ")
        user_number = float(user_input)
        result = 2 + user_number
        print(f"Результат: {result}")
    except ValueError:
        print(f"Неподходящий тип данных. Ожидалось число.")

add_two()
add_two()
add_two()
```
### Результат.
![Меню](https://github.com/ElizabethSmol/ChernovaZPIE_20_2/blob/pic/sam_10_3.PNG)

## Выводы

Данный код создает функцию add_two, которая выполняет условия задачи по сложению чисел. Также выводятся строки с использованием функции `print()`. Строки содержат значения:

1. `print(f"Результат: {result}")`: Выводится при выполнении функции, если введено число
2. `print(f"Неподходящий тип данных. Ожидалось число.")`: Выводится "Неподходящий тип данных. Ожидалось число.", используя исключение ValueError, и программа выводит сообщение вместо результата сложения.

## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
import time
# Определение декоратора для измерения времени выполнения функций
def decorator(func):
    def wrapper(*args, **kwargs):
        # Запуск таймера
        start_time = time.time()
        # Выполнение функции и сохранение результата
        result = func(*args, **kwargs)
        # Завершение таймера после выполнения функции
        end_time = time.time()
        # Вычисление времени выполнения функции
        execution_time = end_time - start_time
        # Вывод времени выполнения функции на экран
        print(f"Время выполнения функции '{func.__name__}': {execution_time} секунд")
        # Возвращение результата выполнения функции
        return result

    # Возвращение обернутой функции
    return wrapper
# Применение декоратора к медленной функции
@decorator
def slow_function():
    # Имитация медленной работы
    time.sleep(2)
    print("Медленная функция выполнена")
# Применение декоратора к быстрой функции
@decorator
def fast_function():
    print("Быстрая функция выполнена")
# Вызов функций
slow_function()
fast_function()
```
### Результат.
![Меню](https://github.com/ElizabethSmol/ChernovaZPIE_20_2/blob/pic/sam_10_4.PNG)

## Выводы

Данный код создает декоратор timing_decorator, который измеряет и выводит время выполнения функций, к которым он применяется. Затем применяется этот декоратор к двум функциям slow_function и fast_function.

1. `print("Медленная функция выполнена")"`: строка выводит "Медленная функция выполнена";
2. `print("Быстрая функция выполнена")`: строка выводит "Быстрая функция выполнена";
3. `print(f"Время выполнения функции '{func.__name__}': {execution_time} секунд")`: строка выводит func.__name__: атрибут функции, который содержит её имя, execution_time: переменную, которая содержит время выполнения функции, измеренное в секундах.


## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключецие, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода

```python
# Создаем собственное исключение CustomException для проверки корректности пароля и логина
class CustomException(Exception):
    def __init__(self, message):
        super().__init__(message)

# Функция для проверки пароля
def check_password(password):
    # Проверка длины пароля
    if len(password) < 8:
        raise CustomException("Пароль слишком короткий (минимум 8 символов)")
    # Проверка наличия хотя бы одной цифры
    if not any(char.isdigit() for char in password):
        raise CustomException("Пароль должен содержать хотя бы одну цифру")

# Функция для проверки логина
def check_username(username):
    # Проверка длины логина
    if len(username) < 4:
        raise CustomException("Логин слишком короткий (минимум 4 символа)")
    # Проверка наличия только букв и цифр
    if not username.isalnum():
        raise CustomException("Логин должен состоять только из букв и цифр")

try:
    # Примеры проверки допустимых пароля и логина
    username = "user123"
    check_username(username)
    password = "passw0rd"
    check_password(password)
    print("Регистрация прошла успешно.")
except CustomException as e:
    # Обработка собственного исключения
    print(f"Ошибка при регистрации: {e}")
try:
    # Примеры проверки недопустимого логина
    username = "us"
    check_username(username)
    password = "passw0rd"
    check_password(password)
    print("Регистрация прошла успешно.")
except CustomException as e:
    # Обработка собственного исключения
    print(f"Ошибка при регистрации: {e}")
```
### Результат.
![Меню](https://github.com/ElizabethSmol/ChernovaZPIE_20_2/blob/pic/sam_10_5.PNG)

## Выводы

В данном коде создаются: исключение CustomException, функции для проверок логина и пароля def check_username(username): и def check_password(password):. 

## Общие выводы по теме
Таким образом, при работе по теме 10, мы сделали вывод, что декораторы - это полезный инструмент, который позволяет изменять поведение функций или методов, не изменяя их исходный код. Они часто используются для добавления дополнительной функциональности, такой как измерение времени выполнения или обработка исключений. 
